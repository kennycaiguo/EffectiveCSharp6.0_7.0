2019.03.03
項目11：.NETリソース管理を理解する

・2019.03.03：C++のデストラクタを利用してリソースを開放する
(概要)
	・C++プロジェクトを作成し、CriticalSectionクラスのデストラクタでリソースを開放する
	利用者側は、CriticalSectionをオート変数として定義する
(プロジェクト)
	CppDestructor：デストラクタの動作を確認するサンプルアプリ

・2019.03.03：C＃のファイナライザを利用してリソースを開放する
(概要)
	・C＃プロジェクトを作成し、CriticalSectionクラスのファイナライザでリソースを開放する
	利用者側は、CriticalSectionオブジェクトをヒープ上に作成する
(プロジェクト)
	CSharpFinalizer：ファイナライザの動作を確認するサンプルアプリ

項目11：.NETリソース管理を理解する

・2019.03.03：C++のデストラクタを利用してリソースを開放する
(概要)
	・C++プロジェクトを作成し、CriticalSectionクラスのデストラクタでリソースを開放する
	利用者側は、CriticalSectionをオート変数として定義する
(プロジェクト)
	CppDestructor：デストラクタの動作を確認するサンプルアプリ


2019.03.04
項目12：メンバには割当演算子よりもオブジェクト初期化子を使用すること

・2019.03.04：オブジェクト初期化子
(概要)
	・オブジェクト初期化子の利用例
(プロジェクト)
	ObjectInitializer：オブジェクト初期化子によってListメンバを初期化
	
・2019.03.04：システムによるゼロ初期化
(概要)
	・システムによって値型変数をゼロ初期化、明示的な初期化処理を省略
(プロジェクト)
	ZeroInitialize：システムによって値型変数を初期化して表示
(コメント)
	オート変数の値型変数を初期化子なしで宣言すると、「未割当のローカル変数」のエラーが出る
	
・2019.03.04：オブジェクト初期化子とコンストラクタによる複数回の初期化
システムによるゼロ初期化
(概要)
	・オブジェクト初期化子によって初期化後、さらにコンストラクタによって別の値に初期化
(プロジェクト)
	MultipleInitialize：メンバ変数を初期化して表示

	
2019.03.04
項目13：staticメンバを適切に初期化すること

・2019.03.04：staticメンバを利用したシングルトンの実装
(概要)
	・staticメンバ変数を利用してシングルトンパターンを実装
(プロジェクト)
	Singleton：シングルトンインスタンスを複数取得し、同一であることを確認

・2019.03.04：staticコンストラクタ
(概要)
	・staticコンストラクタを利用したシングルトンの実装
(プロジェクト)
	StaticConstructor：シングルトンインスタンスを複数取得し、同一であることを確認

・2019.03.04：staticコンストラクタで例外を処理
(概要)
	・staticコンストラクタ内で発生した例外をコンストラクタ内で処理する（外に出さない）
(プロジェクト)
	StaticInitializerException：シングルトンインスタンスを複数取得し、同一であることを確認


2019.03.04
項目14：初期化ロジックの重複を最小化する

・2019.03.04：コンストラクタ初期化子
(概要)
	・コンストラクタ初期化子を使用して初期化ロジックの重複を省く
(プロジェクト)
	ConstructorInitializer：オーバーロードされた各種コンストラクタにより変数を初期化し、内容を確認

・2019.03.04：コンストラクタのデフォルト引数
(概要)
	・コンストラクタのデフォルト引数を使用して初期化ロジックの重複を省く
	・new制約を満たすために引数なしのコンストラクタを別途定義
(プロジェクト)
	ConstructorDefaultArgument：デフォルト引数つきのコンストラクタにより変数を初期化し、内容を確認
		Listコレクションによってnew制約を確認

・2019.03.04：共通初期化メソッドの呼び出し
(概要)
	・オーバーロードされたコンストラクタから共通初期化メソッドを呼び出す
(プロジェクト)
	CommonInitializerMethod：オーバーロードされた各種コンストラクタにより変数を初期化し、内容を確認

・2019.03.04：共通初期化メソッドからreadonlyメンバーの初期化
(概要)
	・オーバーロードされたコンストラクタから共通初期化メソッドを呼び出す
	・共通初期化メソッドからreadonlyメンバを初期化することができない
(プロジェクト)
	InitializeReadOnlyMember：オーバーロードされた各種コンストラクタにより変数を初期化し、内容を確認


2019.03.04、2019.03.05
項目15：不必要なオブジェクトの生成を避けること

・2019.03.04：IDisposableなローカル変数の使用（Windows　Formアプリ）
(概要)
	・OnPaintハンドラで毎回同じFontオブジェクトを作成してテキストを描画する
(プロジェクト)
	DisposableLocalVariable：Windowsフォームに時刻を描画する

・2019.03.04：IDisposableなローカル変数をメンバ変数に変更（Windows　Formアプリ）
(概要)
	・Fontオブジェクトをメンバ変数として保持。OnPaintハンドラで同Fontオブジェクトを使いまわす
(プロジェクト)
	DisposableMemberVariable：Windowsフォームに時刻を描画する

・2019.03.05：不変型の生成
(概要)
	・Stringオブジェクトを、文字列連結、文字列補完、StringBuilderの3つの方法で生成する
(プロジェクト)
	ImmutableObject：3つの方法で文字列を生成し、表示する


2019.03.05
項目16：コンストラクタ内では仮想メソッドを呼ばないこと

・2019.03.05：親クラスのコンストラクタ内で仮想メソッド呼び出し
(概要)
	・親クラスのコンストラクタ内で仮想メソッドを呼び出し、親子どちらの仮想メソッドが呼ばれるかを確認
(プロジェクト)
	VirtualCall_in_Constructor：親子の仮想メソッド内でそれぞれの文字列を表示

・2019.03.05：親クラスのコンストラクタ内で仮想メソッド呼び出し(C++バージョン)
(概要)
	・親クラスのコンストラクタ内で仮想メソッドを呼び出し、親子どちらの仮想メソッドが呼ばれるかを確認
(プロジェクト)
	VirtualCall_in_Constructor_cpp：親子の仮想メソッド内でそれぞれの文字列を表示

・2019.03.05：親クラスのコンストラクタ内で抽象メソッド呼び出し
(概要)
	・親クラスのコンストラクタ内で抽象メソッドを呼び出し、子クラスのオーバーライドメソッドが呼ばれるかを確認
(プロジェクト)
	AbstractCall_in_Constructor：子クラスのオーバーライドメソッド内で文字列を表示

・2019.03.05：親クラスのコンストラクタ内で抽象メソッド呼び出し(C++バージョン)
(概要)
	・親クラスのコンストラクタ内で抽象メソッドを呼び出し、エラーとなることを確認
(プロジェクト)
	AbstractCall_in_Constructor_cpp：子クラスのオーバーライドメソッド内では文字列を表示
		親クラスの抽象メソッド呼び出しはエラーとなる
（コメント）
	テキストの記述と異なり、B::VFuncが未解決の外部シンボルとなり、リンクエラーが発生する


2019.03.05
項目17：標準的なDisposeパターンを実装する

・2019.03.05：標準的なDisposeパターン
(概要)
	・IDisposableなクラス階層を実装する
	・子クラスと親クラスのそれぞれについてDisposeを行う
	・Dispose後にクラスを使用した場合のエラーを確認する
(プロジェクト)
	DisposableClassTree：IDisposableなクラス階層の構築とDispose

・2019.03.05：Disposableなクラス階層をファイナライズする
(概要)
	・IDisposableなクラス階層を実装する
	・子クラスと親クラスのそれぞれについてファイナライザを行う
(プロジェクト)
	FinalizeDisposableTree：IDisposableなクラス階層の構築とファイナライズ
(コメント)
	派生クラスのファイナライズの実行中に、その中に含まれる親クラスのファイナライザもコールされている

・2019.03.05：ネストしてDisposableをDisposeする
(概要)
	・ネストしたIDisposableなクラスを実装する
	・子クラスと親クラスのそれぞれについてDisposeする
(プロジェクト)
	DisposeNestedDisposable：ネストしたIDisposableをDisposeするテスト
