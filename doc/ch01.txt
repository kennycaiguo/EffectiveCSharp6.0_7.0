第1章：C#言語イディオム

2019.02.17、2019.03.05
項目１：ローカル変数の型をなるべく暗黙的に指定すること

・2019.02.17、2019.03.05：ローカル変数の型推論
(概要)
	・ローカル変数の初期化子期から変数の型を推論する(var)
(プロジェクト)
	TypeInference：ローカル変数の型推論の例

・2019.02.17：組み込み型の型推論
(概要)
	・組み込み型のローカル変数の初期化子期から変数の型を推論する(var)
(プロジェクト)
	BuiltInType：組み込み型のローカル変数の型推論の例


2019.02.17、2019.03.06
項目2：constよりもreadonlyを使用すること

・2019.03.06：constとreadonlyの意味論の違い
(概要)
	・constとreadonlyの使い方の違いをコード例で説明
(プロジェクト)
	ConstReadonly：

・2019.03.06：const定数とreadonly変数を含むアセンブリをバージョンアップした場合の動作
(概要)
	・アプリケーションから外部アセンブリに含まれるconst定数とreadonly変数をアクセスする
	・外部アセンブリをバージョンアップし、dllをリリースした場合の動作の違いを試す
(プロジェクト)
	Application：外部アセンブリを参照するアプリケーション
	Infrastructure：const定数とreadonly変数を含む外部アセンブリ
(コメント)
	・VC2017でこの動作を試すためには以下の手順に従う必要がある
	①InfrastuctureとAppicationを作成・ビルドし、動作確認を行う。この時、Applicationの
		参照プロジェクトにInfrastuctureを加える
	②Infrastrureをバージョンアップ、ビルドし、dllを作成する
	③ビルド後、作成されたdllファイルをAppicationのbin/Debugフォルダにコピーする
	④コマンドラインからApplicationを実行する
		この時、VC2017からからAppicationを実行すると、Applicationが再ビルドされるため、
		目的の動作確認ができない
		
・2019.03.06：アセンブリ毎のアップデートとリリース
(概要)
	・税金関連法のバージョンを指定するアセンブリと、税金法に従った計算を行う複数のアセンブリと、
	　税金の計算アセンブリを利用するアプリケーションが存在する
	・税金法規制の改正に合わせて、法改正に影響される税金計算アセンブリを個別にバージョンアップし、
	　リリースする
	・アプリケーションから各種計算アセンブリが従う税金法規制のバージョンを表示させる
(プロジェクト)
	TaxApplication：税金計算アセンブリを利用するアプリケーション
	TaxComputation1:法規制に合わせて税金計算を行うアセンブリの１つ
	TaxComputation2：法規制に従って税金計算を行うアセンブリのもう１つ
	TaxRevision：法規制のバージョンを表現するconst定数を保持したアセンブリ
(コメント)
	・VC2017でこの動作を試すためには上記コメントを参照


2019.02.17、2019.02.23、2019.03.07
項目3：キャストにはisまたはasを使用すること

・2019.03.07：as演算子の使用法
(概要)
	・as演算子を使用して、object型のオブジェクトをMyTypeに変換する
(プロジェクト)
	As：

・2019.03.07：キャストの使用法
(概要)
	・キャストを使用して、object型のオブジェクトをMyTypeに変換する
(プロジェクト)
	Cast：

・2019.03.07：ユーザ定義の変換演算子がある場合のキャストの振る舞い
(概要)
	・ユーザ定義型に変換演算子が定義されている場合に、as及びキャストを使用した時の変換の成否を確認
(プロジェクト)
	TypeConversion：

・2019.03.07：組み込み型へのas変換
(概要)
	・組み込み型intにas変換するためには、null許容型を使用する
(プロジェクト)
	AsInt：

・2019.03.07：IEnumerableを使用したforeachの型変換
(概要)
	・IEnumberシーケンスに対して、foreachを使用すると、範囲変数の型にキャスト演算子を使用して
	　型変換を行う。
	・オブジェクト型MyTypeと組み込み型intを要素とするIEnumerableに対して、foreachの動作を確認する
(プロジェクト)
	ForeachIEnumerable：

・2019.03.07：EnumerableCast<T>
(概要)
	・IEnumberシーケンスに対して、Enumerable.Cast<T>を使用して目的の型のシーケンスに変換する
(プロジェクト)
	EnumerableCast：


2019.02.23、2019.03.27
項目4：string.Format()を補完文字列に置き換える

・2019.03.07：文字列補完
(概要)
	・文字列補完の文法と使い方
(プロジェクト)
	StringInterpolation：
（コメント）
	・Console.WriteLine($"円周率の値は{(round ? Math.PI.ToString() : Math.PI.ToString("F2"))}");
	において、リテラル文字列指定$@"は不要

・2019.03.07：補完文字列式
(概要)
	・補完文字列の書式に指定できる式の使い方
(プロジェクト)
	InterpolatedExpression：
（コメント）
	・補完文字列途中で改行する方法が不明

2019.02.23、2019.03.07
項目5：カルチャ固有の文字列よりもFormattableStringを使用すること

・2019.03.07：FormatableStringの利用法
(概要)
	・補完文字列は出力先に応じてstringまたはFormatableString型となる
	　（オーバーロードなど、複数選択があるときはstring優先）
	・FormatableStringにローカライズ情報を設定する方法
(プロジェクト)
	FormatString
(コメント)
	・コード例のstring.Fromat(null,・・・)はランタイムエラーとなる。代わりに、
	　src.ToString(System.Globalization.CultureInfo.CreateSpecificCulture("de-de"))
	とした
	
2019.02.23、2019.03.07
項目6：文字列指定のAPIを指定しないこと

・2019.03.07：PropertyChangedEventHandlerでnameof演算子の使用法
(概要)
	・PropertyChangedEventHandlerで、変更されたプロパティー名をnameof演算子を使って
	　PropertyChangedEventArgsの引数に設定する
(プロジェクト)
	PropertyChagned

・2019.03.07：Exceptionのコンストラクタ引数でnameof演算子を使用
(概要)
	・ArgumentNullExceptionのコンストラクタで、nullの関数引数名をnameof演算子で取得
(プロジェクト)
	NullArgument


2019.02.24、2019.03.07
項目7：デリゲートを使用してコールバックを表現する

・2019.03.07：ラムダ式でコールバックを表現
(概要)
	・コールバックを用いるList<int>のメンバ関数の使用例
(プロジェクト)
	ListCallback
(コメント)
	・テキストの記述と異なり、List<int>.Find()は、マッチした最初の要素(int)を返す

・2019.03.07：マルチキャストデリゲート
(概要)
	・長時間実行されるタスクを複数実行する時、実行継続の可否をコールバックを用いて問い合わせる
	・コールバックのデリゲートに複数の関数が登録されているとき、最後の関数が返した値が使われ、
	　それ依存の関数リターン値は無視される問題がある
	・この問題に対しては、マルチキャストを構成する各デリゲートを明示的に呼び出すことで対策する
(プロジェクト)
	MulticastDelegate

2019.02.24、2019.03.08
項目8：イベントの呼び出し時にnull条件演算子を使用すること

・2019.03.08：イベント呼び出し
(概要)
	・イベントにハンドラが登録されている状態と、登録されていない状態（イベント値はnull）で、
	　ハンドラを呼び出す
(プロジェクト)
	CallEventHandler

・2019.03.08：イベント呼び出し時にnullチェックを行う
(概要)
	・イベントにハンドラが登録されていない状態（イベント値はnull）を事前判定して、
	　ハンドラを呼び出す
(プロジェクト)
	CheckEventHandler

・2019.03.08：イベントのnullチェック後にハンドラを呼び出すコードのレースコンディション
(概要)
	・if文でイベントのnullチェック後にハンドラを呼び出すコードがマルチスレッドで
	レースコンディションを引き起こす状況を確認
(プロジェクト)
	TestRaceCondition

・2019.03.08：イベントをコピーすることでレースコンディションを解消する
(概要)
	・イベントのコピー後に、コピーされたイベントのnulll判定とハンドラ呼び出しを行うことで
	　レースコンディションを解消する
(プロジェクト)
	TestThreadSafe

・2019.03.08：null条件演算子でイベントハンドラをコールことでレースコンディションを解消する
(概要)
	・イベントに対してnull条件演算子経由でInvokeメソッドを呼び出すことで、レースコンディション
	　を解消する
(プロジェクト)
	TestNullConditionalOperator


2019.02.24、2019.03.08
項目9：ボックス化およびボックス化解除を最小限に抑える

・2019.03.08：補完文字列操作でボックス化とボックス化解除が行われる例
(概要)
	・補完文字列の書式に値型を指定するとボックス化が行われて、System.Object配列に格納される
	・その後で、文字列に変換する際にボックス化解除された値型に対してToStringメソッドが呼び出される
(プロジェクト)
	Boxing

・2019.03.08：変更可能な値型をコレクションに格納する際の潜在的な問題（コピー操作）
(概要)
	・変更可能な構造体をコレクションに格納し、コレクション上で操作すると暗黙的に要素のコピーが
	　とられて、そのコピー上で操作が行われる。
	・そのため元のコレクションには操作が反映されないという問題が生じる
(プロジェクト)
	MutableValueType


2019.03.02、2019.03.03
項目10：親クラスの変更に応じる場合のみnew修飾子を使用すること

・2019.03.03：外部ライブラリのクラスを親クラスとして利用する独自ライブラリが第3者に利用されている状況
(概要)
	・外部ライブラリBaseWidgetLibを使用して、独自ライブラリMyWidgetLibをリリース
	・クライアントMyWidgetClientが独自ライブラリMyWidgetLibを利用
(プロジェクト)
	MyWidgetClient：第3者のクライアントアプリ
(参照)
	BaseWidgetLib：外部ライブラリ
	MyWidgetLib：外部ライブラリの親クラスをサブクラス化する独自ライブラリ

・2019.03.03：外部ライブラリの親クラスの新しいメソッド名が独自ライブラリの元々のメソッド名と重複
	new修飾子を指定
(概要)
	・独自ライブラリの元々のメソッド名NormalizeValuesが外部ライブラリの親クラスの
	新しいメソッド名と重複したため、new修飾子を指定
(プロジェクト)
	NewMyWidgetClient：第3者のクライアントアプリ。内容は変更なし
(参照)
	NewBaseWidgetLib：外部ライブラリ。親クラスにサブクラスと重複する新しいメソッドが追加
	NewMyWidgetLib：独自ライブラリ。親クラスと重複するメソッドにnew修飾子を指定

・2019.03.03：外部ライブラリの親クラスの新しいメソッド名が独自ライブラリの元々のメソッド名と重複
	独自ライブラリのメソッド名を変更
(概要)
	・独自ライブラリの元々のメソッド名NormalizeValuesが外部ライブラリの親クラスの
	新しいメソッド名と重複したため、独自ライブラリのメソッド名をNormalizeAllValuesに変更
(プロジェクト)
	UpdatedMyWidgetClient：第3者のクライアントアプリ。独自ライブラリのメソッド名変更に対応
(参照)
	NewBaseWidgetLib：外部ライブラリ。親クラスにサブクラスと重複する新しいメソッドが追加
	UpdatedMyWidgetLib：独自ライブラリ。親クラスと重複するメソッド名を変更



