第1章：C#言語イディオム

2019.02.17、2019.03.05
項目１：ローカル変数の型をなるべく暗黙的に指定すること

・2019.02.17、2019.03.05：ローカル変数の型推論
(概要)
	・ローカル変数の初期化子期から変数の型を推論する(var)
(プロジェクト)
	TypeInference：ローカル変数の型推論の例

・2019.02.17：組み込み型の型推論
(概要)
	・組み込み型のローカル変数の初期化子期から変数の型を推論する(var)
(プロジェクト)
	BuiltInType：組み込み型のローカル変数の型推論の例


2019.02.17、2019.03.06
項目2：constよりもreadonlyを使用すること

・2019.03.06：constとreadonlyの意味論の違い
(概要)
	・constとreadonlyの使い方の違いをコード例で説明
(プロジェクト)
	ConstReadonly：

・2019.03.06：const定数とreadonly変数を含むアセンブリをバージョンアップした場合の動作
(概要)
	・アプリケーションから外部アセンブリに含まれるconst定数とreadonly変数をアクセスする
	・外部アセンブリをバージョンアップし、dllをリリースした場合の動作の違いを試す
(プロジェクト)
	Application：外部アセンブリを参照するアプリケーション
	Infrastructure：const定数とreadonly変数を含む外部アセンブリ
(コメント)
	・VC2017でこの動作を試すためには以下の手順に従う必要がある
	①InfrastuctureとAppicationを作成・ビルドし、動作確認を行う。この時、Applicationの
		参照プロジェクトにInfrastuctureを加える
	②Infrastrureをバージョンアップ、ビルドし、dllを作成する
	③ビルド後、作成されたdllファイルをAppicationのbin/Debugフォルダにコピーする
	④コマンドラインからApplicationを実行する
		この時、VC2017からからAppicationを実行すると、Applicationが再ビルドされるため、
		目的の動作確認ができない
		
・2019.03.06：アセンブリ毎のアップデートとリリース
(概要)
	・税金関連法のバージョンを指定するアセンブリと、税金法に従った計算を行う複数のアセンブリと、
	　税金の計算アセンブリを利用するアプリケーションが存在する
	・税金法規制の改正に合わせて、法改正に影響される税金計算アセンブリを個別にバージョンアップし、
	　リリースする
	・アプリケーションから各種計算アセンブリが従う税金法規制のバージョンを表示させる
(プロジェクト)
	TaxApplication：税金計算アセンブリを利用するアプリケーション
	TaxComputation1:法規制に合わせて税金計算を行うアセンブリの１つ
	TaxComputation2：法規制に従って税金計算を行うアセンブリのもう１つ
	TaxRevision：法規制のバージョンを表現するconst定数を保持したアセンブリ
(コメント)
	・VC2017でこの動作を試すためには上記コメントを参照


2019.02.17、2019.02.23、2019.03.07
項目3：キャストにはisまたはasを使用すること

・2019.03.07：as演算子の使用法
(概要)
	・as演算子を使用して、object型のオブジェクトをMyTypeに変換する
(プロジェクト)
	As：

・2019.03.07：キャストの使用法
(概要)
	・キャストを使用して、object型のオブジェクトをMyTypeに変換する
(プロジェクト)
	Cast：

・2019.03.07：ユーザ定義の変換演算子がある場合のキャストの振る舞い
(概要)
	・ユーザ定義型に変換演算子が定義されている場合に、as及びキャストを使用した時の変換の成否を確認
(プロジェクト)
	TypeConversion：

・2019.03.07：組み込み型へのas変換
(概要)
	・組み込み型intにas変換するためには、null許容型を使用する
(プロジェクト)
	AsInt：

・2019.03.07：IEnumerableを使用したforeachの型変換
(概要)
	・IEnumberシーケンスに対して、foreachを使用すると、範囲変数の型にキャスト演算子を使用して
	　型変換を行う。
	・オブジェクト型MyTypeと組み込み型intを要素とするIEnumerableに対して、foreachの動作を確認する
(プロジェクト)
	ForeachIEnumerable：


2019.02.23
項目4：string.Format()を補完文字列に置き換える
	
2019.02.23
項目5：カルチャ固有の文字列よりもFormattableStringを使用すること
	
2019.02.23
項目6：文字列指定のAPIを指定しないこと

2019.02.24
項目7：デリゲートを使用してコールバックを表現する

2019.02.24
項目8：イベントの呼び出し時にnull条件演算子を使用すること

2019.02.24
項目9：ボックス化およびボックス化解除を最小限に抑える

2019.03.02、2019.03.03
項目10：親クラスの変更に応じる場合のみnew修飾子を使用すること

・2019.03.03：外部ライブラリのクラスを親クラスとして利用する独自ライブラリが第3者に利用されている状況

(概要)
	・外部ライブラリBaseWidgetLibを使用して、独自ライブラリMyWidgetLibをリリース
	・クライアントMyWidgetClientが独自ライブラリMyWidgetLibを利用
(プロジェクト)
	MyWidgetClient：第3者のクライアントアプリ
(参照)
	BaseWidgetLib：外部ライブラリ
	MyWidgetLib：外部ライブラリの親クラスをサブクラス化する独自ライブラリ

・2019.03.03：外部ライブラリの親クラスの新しいメソッド名が独自ライブラリの元々のメソッド名と重複
	new修飾子を指定

(概要)
	・独自ライブラリの元々のメソッド名NormalizeValuesが外部ライブラリの親クラスの
	新しいメソッド名と重複したため、new修飾子を指定
(プロジェクト)
	NewMyWidgetClient：第3者のクライアントアプリ。内容は変更なし
(参照)
	NewBaseWidgetLib：外部ライブラリ。親クラスにサブクラスと重複する新しいメソッドが追加
	NewMyWidgetLib：独自ライブラリ。親クラスと重複するメソッドにnew修飾子を指定

・2019.03.03：外部ライブラリの親クラスの新しいメソッド名が独自ライブラリの元々のメソッド名と重複
	独自ライブラリのメソッド名を変更

(概要)
	・独自ライブラリの元々のメソッド名NormalizeValuesが外部ライブラリの親クラスの
	新しいメソッド名と重複したため、独自ライブラリのメソッド名をNormalizeAllValuesに変更
(プロジェクト)
	UpdatedMyWidgetClient：第3者のクライアントアプリ。独自ライブラリのメソッド名変更に対応
(参照)
	NewBaseWidgetLib：外部ライブラリ。親クラスにサブクラスと重複する新しいメソッドが追加
	UpdatedMyWidgetLib：独自ライブラリ。親クラスと重複するメソッド名を変更



