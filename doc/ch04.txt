第4章　LINQを扱う処理

2019.03.21、2019.03.23、2019.03.24
項目29:コレクションを返すメソッドではなくイタレータを返すメソッドとすること

・2019.03.21：イタレータメソッド
(概要)
	・すべてのアルファベット文字を生成するイタレータメソッド
(プロジェクト)
	IteratorMethod：テストプログラム

・2019.03.21：巨大なシーケンスを生成するイタレータメソッド
(概要)
	・Enumerable.Range()を使用して、0から最大値までのすべての整数値を生成するイタレータを利用して、
	　100個までの素数を表示する
(プロジェクト)
	EnumerableRange：テストプログラム

・2019.03.23、2019.03.24：引数をとるイタレータメソッド
(概要)
	・引数で指定された2つの文字間の文字を生成するイタレータメソッド
	・イタレータメソッド内では、ループに入る前に引数チェックを行うが、イタレータメソッドの
	　呼び出し側で反復を実際に実行するまでエラーが発生しない
	・コンパイラ生成のイタレータコードに対しても同様のチェックを行う
(プロジェクト)
	IteratorMethodWithArguments：テストプログラム

・2019.03.24：イタレータメソッドにおいて、引数のチェックを分離
(概要)
	・引数のチェックをした後で、内部のイタレータメソッドを呼び出すことで、エラーがあった場合には、
	　反復を開始する前に例外を発生させることが可能となる
(プロジェクト)
	SeparateErrorCheck：テストプログラム


2019.03.24、2019.03.25
項目30:ループよりもクエリ構文を使用すること

・2019.03.24：ループ構文
(概要)
	・ループ構文を使用して、0から100未満の整数の2乗を出力する
(プロジェクト)
	LoopStatement：テストプログラム


・2019.03.24：クエリ構文
(概要)
	・クエリ構文を使用して、0から100未満の整数の2乗を出力する
(プロジェクト)
	QueryStatement：テストプログラム

・2019.03.24：ネストしたループ処理とネストしたクエリ処理の比較
(概要)
	・0から100未満の整数の組み合わせのペアを、ネストしたループ処理とクエリしたクエリ処理によって
	　生成する
(プロジェクト)
	GenerateTuple：テストプログラム

・2019.03.24：ネストしたループとネストしたクエリでフィルタされたシーケンスを生成
(概要)
	・0から100未満の整数の組み合わせの中で、要素の和が100未満のペアを、ネストしたループ処理と
	　クエリしたクエリ処理によって生成する
(プロジェクト)
	GenerateFilteredTuple：テストプログラム


・2019.03.24：ループとクエリでフィルタされ、ソートされたシーケンスを生成
(概要)
	・0から100未満の整数の組み合わせの中で、要素の和が100未満のペアを、原点からの距離の
	　降順で生成する処理を、ループとクエリで行う
(プロジェクト)
	GenerateFilteredSortedTuple：テストプログラム

・2019.03.24：フィルタされ、ソートされたシーケンスをクエリメソッドによって生成
(概要)
	・0から100未満の整数の組み合わせの中で、要素の和が100未満のペアを、原点からの距離の
	　降順で生成する処理を、クエリメソッドで行う
(プロジェクト)
	QueryMethod：テストプログラム


2019.03.26
項目31：シーケンス用の組み合わせ可能なAPIを作成する

・2019.03.26：ループ構造を使って整数入力を重複なく出力する
(概要)
	・整数のシーケンスを受け取り、出力コンソールに重複なく出力する
(プロジェクト)
	UniquLoop：テストプログラム

・2019.03.26：イタレータメソッドを使って、整数のシーケンスの重複を取り除く
(概要)
	・整数のシーケンスを受け取り、重複を取り除いたシーケンスを返すイタレータメソッドを実装する
	・これを使って整数入力を出力コンソールに重複なく出力する
(プロジェクト)
	UniquIterator：テストプログラム

・2019.03.26：上記イタレータメソッドのトレース
(概要)
	・整数のシーケンスを受け取り、重複を取り除いたシーケンスを返すイタレータメソッドの動作を
	　トレースする
	・これを使って整数入力を出力コンソールに重複なく出力する
(プロジェクト)
	TraceUniquIterator：テストプログラム

・2019.03.26：入力シーケンスの重複を取り除いたシーケンスを返すジェネリックなイタレータメソッド
(概要)
	・ジェネリック型の入力シーケンスを受け取り、重複を取り除いた出力シーケンスを返す
	　ジェネリックなイタレータメソッドを実装する
	・これを使って整数入力と文字列入力を出力コンソールに重複なく出力する
(プロジェクト)
	GenericUniquIterator：テストプログラム

・2019.03.26：イタレータメソッドの合成
(概要)
	・入力シーケンスの重複を取り除いて出力シーケンスとするイタレータの出力を、入力シーケンス
	　の要素の2乗を出力シーケンスとするイタレータの入力とする(つまり、重複を取り除いて2乗する)
(プロジェクト)
	SquareUniquIterator：テストプログラム

・2019.03.26：2つの入力シーケンスを組み合わせて出力シーケンスとする
(概要)
	・2つの文字列の入力シーケンスの要素の組を要素とするシーケンスを出力する
(プロジェクト)
	ZipStringSequence：テストプログラム


2019.03.27、2019.03.28
項目32：反復処理をAction、Predicate、Funcと分離する

・2019.03.27：リストに対する、PredicateとFuncコールバック処理
(概要)
	・整数のリストに対して以下を行う、
		（Predicate)RemoveAllを使って、値が5である要素をすべて削除する
		（Func)ForEachメソッドを使って、リスト内の要素をすべて表示する
(プロジェクト)
	ListManipulate：テストプログラム
(コメント)
	テキストの記述と異なり、myInts.RemoveAll()は起動オブジェクトを変更する

・2019.03.27：ジェネリックフィルタWhere
(概要)
	・任意の型のシーケンスに対して、Predicateによって要素をフィルターする汎用フィルター
(プロジェクト)
	WhereFilter：テストプログラム
(コメント)
	・テキストのコード例で、ArgumentNullExceptionの第1引数は引数名でなければならない

・2019.03.27：N番目ごとの要素を返すフィルター
(概要)
	・任意の型のシーケンスに対して、N番目毎の要素を出力シーケンスに含めるフィルター
(プロジェクト)
	EveryNthItemFilter：テストプログラム

・2019.03.28：シーケンス内の要素を変換する(入力と出力が同じ型）
(概要)
	・入力シーケンスの要素を変換し、新しいシーケンスを返す。入力と出力は同じ型に限定
(プロジェクト)
	SameTypeConverter：テストプログラム

・2019.03.28：シーケンス内の要素を変換する(入力と出力が異なる型）
(概要)
	・入力シーケンスの要素を変換し、新しいシーケンスを返す。入力と出力は任意に指定可能
(プロジェクト)
	DifferentTypeConverter：テストプログラム


2019.03.28
項目33：要求に応じてシーケンスの要素を生成する

・2019.03.28：整数のリストを生成する
(概要)
	・整数のリストを生成し、以下を行う
		・BindingListによってデータバインディングをサポートする
		　同一のListを参照する２つのBindingListの片方を変更すると、他方にも影響することを確認
		・リストの先頭から条件を満たす要素からなるシーケンスを返す（匿名デリゲートとラムダ式を使う）
(プロジェクト)
	CreateIntList：テストプログラム
(コメント)
	・テキストのコード例で、BindingListの引数となるCreateSequenceの結果をToListで変換すると、
	　テキストの意図と反すると思われる。代わりに以下のようなコード例とした

            var list = CreateSequence(100, 0, 5);
            var data1 = new BindingList<int>(list);
            var data2 = new BindingList<int>(list);

            data1[5] = 10000;
            foreach (var i in data2)
                Console.Write("{0} ", i);
            Console.WriteLine();

・2019.03.28：整数のシーケンスを生成する
(概要)
	・イタレータメソッドを使って整数のシーケンスを生成し、以下を行う
		・BindingListによってデータバインディングをサポートする。
		　整数シーケンスからListを生成することで、2つの独立したBindingLinstを得る
		・シーケンスの先頭から条件を満たす要素からなるシーケンスを返す
		（匿名デリゲートとラムダ式を使う）
(プロジェクト)
	GenerateIntSequence：テストプログラム


2019.03.30
項目34：関数引数を使用して役割を分離する

・2019.03.30：List<T>.RemoveAllをインターフェースで実装する
(概要)
	・List<T>.RemoveAllと同等な機能を持った独自のクラスMyListを実装する
	・MyList<T>｡RemoveAllでは、インターフェースIPredicate<T>を引数として受け取り、
	　そのMatchメソッドをコールバックすることで、削除の判定をする
(プロジェクト)
	ListRemoveAll：テストプログラム

・2019.03.30：Zip関数をジェネリックメソッドとデリゲートで実装する
(概要)
	・2つの任意のシーケンスを任意に組み合わせる汎用のZip関数を、ジェネリックメソッドと
	　デリゲート引数として実現する
(プロジェクト)
	GenericZip：テストプログラム


・2019.03.30：項目33のCreateSequenceをジェネリックメソッドとデリゲートで実装する
(概要)
	・指定個数のシーケンスを、ジェネリックメソッドとデリゲート（シーケンスの各要素を返す関数）
	　によって実現する
(プロジェクト)
	GenericCreateSequence：テストプログラム
(コメント)
	テキストの例では、シーケンス出力が項目33のものと異なる結果となる（最初の要素が０とならない）
	ここでは、以下のようにコールバック関数にループのインデックスを渡すように変更した
	
        public static IEnumerable<T> CreateSequence<T>(
            int numberOfElements,
            Func<int, T> generator)
        {
            for (var i = 0; i < numberOfElements; i++)
                yield return generator(i);
        }
	
・2019.03.30：合計を計算するメソッドをジェネリックメソッドとデリゲートで実装する
(概要)
	・任意の型のシーケンスの合計を計算するメソッドを、ジェネリックメソッドとデリゲート
	　（アキュムレータとして機能する）によって実現する
(プロジェクト)
	GenericSum：テストプログラム

・2019.03.30：任意の入力シーケンスの合計（Fold)をジェネリックメソッドとデリゲートで実装する
(概要)
	・任意の型のシーケンスの合計（Fold)を計算するメソッドを、ジェネリックメソッドとデリゲート
	　（アキュムレータとして機能する）によって実現する
(プロジェクト)
	GenericFold：テストプログラム


2019.03.30、2019.03.31
項目35：拡張メソッドをオーバーロードしないこと

・2019.03.30：同一シグネチャを持つ拡張メソッドを名前空間の間でオーバーロードする
(概要)
	・外部のライブラリに含まれるPersonクラスを拡張する目的で、拡張メソッドを使用する
	・また、同一のシグネチャを持つ２つの拡張メソッドをオーバーロードする
(プロジェクト)
	OverloadExtension：テストプログラム
	PersonLib：外部参照ライブラリ。Personクラスを定義する

・2019.03.30：拡張メソッドのオーバーロードの代わりに、２つの静的メソッドで実装
(概要)
	・同一シグネチャを持つかう超メソッドをオーバーロードするのではなく、２つの異なる
	　シグネチャを持った静的メソッドとして機能を実現する
(プロジェクト)
	StaticUtilityMethod：テストプログラム
	PersonLib：外部参照ライブラリ。Personクラスを定義する


2019.03.31、2019.04.02、2019.04.03、2019.04.06
項目36：クエリ式とメソッド呼び出しの対応を把握する

・2019.03.31：where句とWhereメソッド
(概要)
	・where句を使用した例題と、where句が変換されたWhereメソッドのコードを確認する
(プロジェクト)
	WhereMethod：テストプログラム
	LinqAnalizer:Linqを分析するライブラリ
(コメント)
	・テキストのコード例では、整数配列の初期化時に以下のコンパイルエラーが出る

		配列初期化子で暗黙的に型指定された変数を初期化することはできません。
            //var numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
            var numbers = new int[]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

・2019.03.31：select句とSelectメソッド
(概要)
	・select句を使用した例題と、select句が変換されたSelectメソッドのコードを確認する
		・単純な非生成型のselect句
		・値を変換するselect句
		・型を変換するselect句
(プロジェクト)
	WhereMethod：テストプログラム
	LinqAnalizer:Linqを分析するライブラリ

・2019.04.02、2019.04.03：orderby句と　OrderBy, OrderByDescending、ThenBy、ThenByDescendingメソッド
(概要)
	・orderby句を使用した例題と、それが変換されたOrderBy、OrderByDescending、ThenBy、
	　ThenByDescendingメソッドのコードを確認する
		・複数の比較項目を持つorderBy句が、OrderByとThenByメソッドに変換されること
		・複数のorderby句を誤ってしてしたソート
		・orderby句が一部 descendingを含む場合、OrderByDescending、ThenByメソッドに変換されること
(プロジェクト)
	OrderByThenMethod：テストプログラム
	LinqAnalizer:Linqを分析するライブラリ

・2019.04.03：group句とGroupByメソッド
(概要)
	・group句を使用した例題と、group句が変換されたGroupByメソッドのコードを確認する
		・継続を含むgroup句、ネストしたクエリを含むgroup句、これを変換したGroupByメソッド
		・グループ内にシーケンスを含むselect句と、Selectメソッド
(プロジェクト)
	WhereMethod：テストプログラム
	LinqAnalizer:Linqを分析するライブラリ

・2019.04.06：複数のfrom句とSelectManyメソッド
(概要)
	・複数のfrom句を使用した例題と、それが変換されたSelectManyメソッドのコードを確認する
		・２つのfrom句の基本的な利用例と変換されたSelectManyメソッド
		・SelectManyメソッドの実装例
		・2つのfrom句とwhereメソッドの組み合わせ、変換されたSelectMany、Whare、Selectメソッド
		・３つのfrom句と、変換された２つのSelectManyメソッド
(プロジェクト)
	SelectManyMethod：テストプログラム
(コメント)
	・テキストの表示例とは異なり、匿名型のオブジェクトの表示にはoddNumber等のプロパティー名
	　が含まれる
	・拡張メソッドは、staticクラスのpublic static メソッドして定義しなけらばならない
	　Programクラスのstaticメソッドとして拡張メソッドを定義すると、Programクラスからも
	　探せなくなる

・2019.04.06：join句とJoin、GroupJoinメソッド
(概要)
	・join句を使用した例題と、join句が変換されたJoinメソッド、GroupJoinメソッドのコードを確認する
		・join句の使用例とそれが変換されたJoinメソッド
		・join into 句の使用例とそれが変換されたGroupJoinメソッド
(プロジェクト)
	WhereMethod：テストプログラム


2019.04.10
項目37：クエリを即時評価でなく遅延評価するすること

・2019.04.10：クエリ（イタレータメソッド）の遅延評価
(概要)
	・イタレータメソッドを遅延評価するコード例
(プロジェクト)
	LazyEvaluation：テストプログラム

・2019.04.10：クエリの合成
(概要)
	・クエリの合成を行い、オリジナルのクエリと合成したクエリを時間差をおいて走査する
(プロジェクト)
	QueryComposition：テストプログラム

・2019.04.10：無限シーケンスをクエリ(Take)
(概要)
	・無限シーケンスをTakeの入力とする。Takeにしていされた個数までで打ち切られる
(プロジェクト)
	InfiniteSequence_Take：テストプログラム

・2019.04.10：無限シーケンスをクエリ(Where)
(概要)
	・無限（正確には巨大な）シーケンスを入力とし、where句でフィルターする。
	　入力シーケンスが完了するまで、走査を続ける
(プロジェクト)
	InfiniteSequence_Where：テストプログラム

・2019.04.10：データをフィルターした後でソートする
(概要)
	・データ全体をソートした後でフィルタする場合と、データをフィルタした後で残ったデータを
	　ソートする場合の性能を比較する
(プロジェクト)
	SortFilteredData：テストプログラム


項目39：FuncやAction内では例外をスローしないこと

・2019.04.13、2019.04.14：シーケンスの走査中に要素を変更するAction内で例外をスローする
(概要)
	・シーケンスの走査中にEmployee要素のSalaryプロパティーを変更する例。
	　Action内で例外をスローすると、シーケンスの一部が更新され、一部は未更新となり、
	　矛盾した状態となる
	・Salaryプロパティの無効な値として、ManValueを用いる
	（1.05M倍すると、OverflowExceptionを発生する）
(プロジェクト)
	ExceptonInSequence：テストプログラム
	EmployeeLib：Employeeクラスのライブラリ

・2019.04.14：シーケンスの走査中に要素を変更しないAction内で例外をスローする
(概要)
	・シーケンスの走査中にEmployee要素を参照する例として、従業員全員の合計を計算する
	　Action内で例外をスローしても、元のシーケンスは変更されないので、矛盾した状態とはならない
	・Salaryプロパティの無効な値として、MaxValueを用いる
	（Salaryの合計をとるとOverflowExceptionを発生する）
(プロジェクト)
	SumupSalary：テストプログラム
	EmployeeLib：Employeeクラスのライブラリ

・2019.04.14：エラーが発生する要素を無視する
(概要)
	・シーケンスの要素の中でAction（Salaryを1.05M倍する）実行時にエラーが発生する要素を無視する
	　具体的には、Lis<>.FindAllメソッドを使用して、エラーの発生しない要素だけを集めて
	　Actionを適用する
(プロジェクト)
	IgnoreInvalidElements：テストプログラム
	EmployeeLib：Employeeクラスのライブラリ

・2019.04.14：シーケンスのコピーに対して変更した後、成功した場合にオリジナルを置換する
(概要)
	・Employeeリストのコピーを作成し、コピーに対してSalaryを1.05M倍する
	　もし、この過程でエラーが発生しなかった場合に限り、更新されたコピーを
	　オリジナルのリストに置換する
(プロジェクト)
	ModifyCopyThenUpdate：テストプログラム
	EmployeeLib：Employeeクラスのライブラリ
(コメント)
	テキストで、オリジナルのリストをコピーして修正する際、
	
		MonthlySalary = e.MonthlySalary *= 1.05M

	とすると、オリジナルのリストそのものを変更してしまう(*=演算子を使うので）
	以下のように修正

		MonthlySalary = e.MonthlySalary * 1.05M


2019.04.17、2019.04.18、2019.04.19、2019.04.20
項目41：コストのかかるリソースを維持し続けないこと

・2019.04.17：クロージャによるオブジェクトの寿命の延長
(概要)
	・関数の内部変数を含むクロージャを参照するオブジェクトをリターンすることで
	　内部変数の寿命を関数のリターン後も有効とする
(プロジェクト)
	Closure：テストプログラム
（コメント）
	この例では、以下のような参照関係がある
	Extensions.Generatorが作成するIEnumerable<int>　
	⇒　IEnumerableが内部で保持するデリゲートFunc<int>
	⇒　デリゲートが参照するメンバ関数を含むクロージャ

・2019.04.18：CSVをパースして、行と要素が入れ子になったシーケンスを返す
(概要)
	・CSVファイルをオープンしたReaderオブジェクトを与えて、CSVの各行、各要素のシーケンス
	　IEnumerable<IEnumerable<int>>を返す関数の例
	・呼び出し元に、CSVファイルに対応したReaderをクローズするタイミングを与えることできない
	　ことが問題となる
(プロジェクト)
	EnumerableCSV：テストプログラム

・2019.04.19：CSVファイルをオープンし、行と要素が入れ子になったシーケンスを返し、ファイルをクローズ
(概要)
	・CSVファイル名を与えて、CSVの各行、各要素のシーケンスIEnumerable<IEnumerable<int>>を返す
	　イタレータ関数の例
	・CSVファイルのストリームを保持したusingグロックの内部でyield return を使用することで、
	　シーケンスの終了後にストリームを自動的にクローズする
(プロジェクト)
	ParseCSVFile：テストプログラム

・2019.04.19：クロージャを参照するクエリ式がクロージャをDisposeするタイミング
(概要)
	・クエリ式の一部にIEnumerable<int>をリターンするイタレータ関数を含める
	・イタレータ関数内で、IDisposalを実装した疑似的なクロージャオブジェクトを参照させる
	・イタレータ関数内で、疑似的なクロージャオブジェクトの作成をusing文の中で行う場合と、
	　using文を使用しない場合で、クロージャオブジェクトの破棄のタイミングを調べる
	・さらに、疑似的なクロージャオブジェクトではなく、本物のクロージャを使用する
	　（通常の方法で、コンパイラに生成させる）
(プロジェクト)
	DisposableClosure：テストプログラム
(コメント)
	・テキストのGeneratorクラスは、クロージャオブジェクトを表現すると思われるので、
	　Closureという名前に変えた
	・実行結果は以下のようになった
		・using文の中で疑似的なクロージャを生成する　⇒　シーケンスの操作の完了でDisposeされる
		・using文を使用しないで疑似的なクロージャを生成する　⇒　Disposeは呼び出されない
		・本物のクロージャを生成させる　⇒　Disposeは呼び出されない

・2019.04.19：アルゴリズムをコールバックと指定し、1回の走査で処理を完了する
(概要)
	・CSVファイル名とアルゴリズムのデリゲートを与えて、CSVの各行、各要素のシーケンス
	　IEnumerable<IEnumerable<int>>を引数にデリゲートをコールバックする
	・一回の走査で処理を完了するので、関数内で、ファイルのオープンとクローズを完結する
	　ことができる
	・指定するアルゴリズムとして、IEnumerable<IEnumerable<int>>を表示するものと、
	　最大値を求めるものを扱う
(プロジェクト)
	AlgorithmCallback：テストプログラム

